import { ChainId, PrehashType, SignableBytes } from "@iov/bcp";
import { ExtendedSecp256k1Signature, Secp256k1, Sha256, Slip10RawIndex } from "@iov/crypto";
import { Encoding, fromHex } from "@iov/encoding";

import { Secp256k1HdWallet } from "./secp256k1hdwallet";

const { toAscii } = Encoding;

describe("Secp256k1HdWallet", () => {
  const defaultChain = "chain123" as ChainId;

  it("returns the concrete type when creating from entropy", () => {
    const wallet = Secp256k1HdWallet.fromEntropy(
      fromHex("51385c41df88cbe7c579e99de04259b1aa264d8e2416f1885228a4d069629fad"),
    );
    expect(wallet).toEqual(jasmine.any(Secp256k1HdWallet));
    expect(wallet.implementationId).toEqual("secp256k1-hd");
  });

  it("returns the concrete type when creating from mnemonic", () => {
    const wallet = Secp256k1HdWallet.fromMnemonic(
      "execute wheel pupil bachelor crystal short domain faculty shrimp focus swap hazard",
    );
    expect(wallet).toEqual(jasmine.any(Secp256k1HdWallet));
    expect(wallet.implementationId).toEqual("secp256k1-hd");
  });

  it("creates correct identities from paths", async () => {
    // Test data generated by the BIP32 tool of https://iancoleman.io/bip39/#english
    // and uncompressed pubkeys from https://www.bitaddress.org/ (Don't get confused
    // by keygen. Just click "Wallet Details" and enter privkey)

    const wallet = Secp256k1HdWallet.fromMnemonic(
      "special sign fit simple patrol salute grocery chicken wheat radar tonight ceiling",
    );
    {
      // m/0'/0
      const identity = await wallet.createIdentity(defaultChain, [
        Slip10RawIndex.hardened(0),
        Slip10RawIndex.normal(0),
      ]);
      expect(identity.pubkey.data).toEqual(
        fromHex(
          "04a7a8d79df7857bf25a3a389b0ecea83c5272181d2c062346b1c64e258589fce0f48fe3900d52ef9a034a35e671329bb65441d8e010484d3e4817578550448e99",
        ),
      );
    }
    {
      // m/0'/1
      const identity = await wallet.createIdentity(defaultChain, [
        Slip10RawIndex.hardened(0),
        Slip10RawIndex.normal(1),
      ]);
      expect(identity.pubkey.data).toEqual(
        fromHex(
          "04ec5fd84554de89c53fcd0670f534930c6ec0cbe761d43a98f6557422e16d25612d2d379d9a9ffff69b1764377a98d772ad00ea38220ec318265cebbd5bda2a66",
        ),
      );
    }
    {
      // m/0'/1/0
      const identity = await wallet.createIdentity(defaultChain, [
        Slip10RawIndex.hardened(0),
        Slip10RawIndex.normal(1),
        Slip10RawIndex.normal(0),
      ]);
      expect(identity.pubkey.data).toEqual(
        fromHex(
          "04d26ce62f44e11c38a79cf7d7530ddd20572f8e7d14c38b0da38eee8aacde9bbc5bd032ae677165381e2981d6745605621409336b28a46c0c93be6f43ed9549be",
        ),
      );
    }
    {
      // m/0'/1/1
      const identity = await wallet.createIdentity(defaultChain, [
        Slip10RawIndex.hardened(0),
        Slip10RawIndex.normal(1),
        Slip10RawIndex.normal(1),
      ]);
      expect(identity.pubkey.data).toEqual(
        fromHex(
          "04c3ff7a943318deacb0c426ac9b03bb69358d1c304eb13e1a2c2a458a46541a5427d2f44dcd6b3dde9abf088f5873cd65b089bd5f7c1cab269ac42c2e5a5d20e9",
        ),
      );
    }
    {
      // m/0'/1/1/0'
      const identity = await wallet.createIdentity(defaultChain, [
        Slip10RawIndex.hardened(0),
        Slip10RawIndex.normal(1),
        Slip10RawIndex.normal(1),
        Slip10RawIndex.hardened(0),
      ]);
      expect(identity.pubkey.data).toEqual(
        fromHex(
          "04f6cbcea9d6a3ebd400b9a134e58f405cc19aff092d344755837099f3ea9258b4403c2547cde4474aabb83594244598eb00d0f46c717c9b16b679f504f142c957",
        ),
      );
    }
    {
      // m/0'/1/1/1'
      const identity = await wallet.createIdentity(defaultChain, [
        Slip10RawIndex.hardened(0),
        Slip10RawIndex.normal(1),
        Slip10RawIndex.normal(1),
        Slip10RawIndex.hardened(1),
      ]);
      expect(identity.pubkey.data).toEqual(
        fromHex(
          "041bcecc3222b74948984b9b3a676814dcd8d7d6d5530caa7d7a3280bf034ba62c75a37a4152b737be25a60c295f26829b1b2377fd6291513ae1681140d0799668",
        ),
      );
    }
  });

  it("creates correct signatures", async () => {
    const wallet = Secp256k1HdWallet.fromMnemonic(
      "special sign fit simple patrol salute grocery chicken wheat radar tonight ceiling",
    );
    // m/0'/0
    // pubkey: 04a7a8d79df7857bf25a3a389b0ecea83c5272181d2c062346b1c64e258589fce0f48fe3900d52ef9a034a35e671329bb65441d8e010484d3e4817578550448e99
    const mainIdentity = await wallet.createIdentity(defaultChain, [
      Slip10RawIndex.hardened(0),
      Slip10RawIndex.normal(0),
    ]);

    const data = toAscii("foo bar") as SignableBytes;
    const signatureBytes = await wallet.createTransactionSignature(mainIdentity, data, PrehashType.Sha256);

    const valid = await Secp256k1.verifySignature(
      ExtendedSecp256k1Signature.fromFixedLength(signatureBytes),
      new Sha256(data).digest(),
      fromHex(
        "04a7a8d79df7857bf25a3a389b0ecea83c5272181d2c062346b1c64e258589fce0f48fe3900d52ef9a034a35e671329bb65441d8e010484d3e4817578550448e99",
      ),
    );
    expect(valid).toEqual(true);
  });

  it("can be cloned", () => {
    const original = Secp256k1HdWallet.fromEntropy(
      fromHex("51385c41df88cbe7c579e99de04259b1aa264d8e2416f1885228a4d069629fad"),
    );
    const clone = original.clone();
    expect(clone).not.toBe(original);
    expect(clone.serialize()).toEqual(original.serialize());
    expect(clone).toEqual(jasmine.any(Secp256k1HdWallet));
    expect(clone.implementationId).toEqual("secp256k1-hd");
  });
});
