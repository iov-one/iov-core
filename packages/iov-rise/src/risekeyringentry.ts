// tslint:disable:readonly-array
import PseudoRandom from "random-js";

import { PrehashType, SignableBytes } from "@iov/bcp-types";
import { Ed25519, Sha256 } from "@iov/crypto";
import { Encoding } from "@iov/encoding";
import {
  DefaultValueProducer,
  Keyring,
  KeyringEntry,
  KeyringEntryId,
  KeyringEntryImplementationIdString,
  KeyringEntrySerializationString,
  LocalIdentity,
  LocalIdentityId,
  PublicIdentity,
  ValueAndUpdates,
} from "@iov/keycontrol";
import { Algorithm, ChainId, PublicKeyBundle, PublicKeyBytes, SignatureBytes } from "@iov/tendermint-types";

import { passphraseToKeypair } from "./derivation";

interface PubkeySerialization {
  readonly algo: string;
  readonly data: string;
}

interface LocalIdentitySerialization {
  readonly pubkey: PubkeySerialization;
  readonly label?: string;
}

interface IdentitySerialization {
  readonly localIdentity: LocalIdentitySerialization;
  readonly passphrase: string;
}

interface LiskKeyringEntrySerialization {
  readonly label: string | undefined;
  readonly id: string;
  readonly identities: ReadonlyArray<IdentitySerialization>;
}

export class RISEKeyringEntry implements KeyringEntry {
  public static readonly implementationId = "rise" as KeyringEntryImplementationIdString;

  /**
   * A convenience function to register this entry type with the global Keyring class
   */
  public static registerWithKeyring(): void {
    const implId = RISEKeyringEntry.implementationId;
    Keyring.registerEntryType(implId, (data: KeyringEntrySerializationString) => {
      return new RISEKeyringEntry(data);
    });
  }

  private static readonly idsPrng: PseudoRandom.Engine = PseudoRandom.engines.mt19937().autoSeed();

  private static generateId(): KeyringEntryId {
    // this can be pseudo-random, just used for internal book-keeping
    const code = PseudoRandom.string()(RISEKeyringEntry.idsPrng, 16);
    return code as KeyringEntryId;
  }

  private static identityId(identity: PublicIdentity): LocalIdentityId {
    const id = identity.pubkey.algo + "|" + Encoding.toHex(identity.pubkey.data);
    return id as LocalIdentityId;
  }

  private static algorithmFromString(input: string): Algorithm {
    switch (input) {
      case "ed25519":
        return Algorithm.ED25519;
      case "secp256k1":
        return Algorithm.SECP256K1;
      default:
        throw new Error("Unknown algorithm string found");
    }
  }

  private static buildLocalIdentity(
    algorithm: Algorithm,
    bytes: PublicKeyBytes,
    label: string | undefined,
  ): LocalIdentity {
    const pubkey: PublicKeyBundle = {
      algo: algorithm,
      data: bytes,
    };
    return {
      pubkey: pubkey,
      label: label,
      id: RISEKeyringEntry.identityId({ pubkey }),
    };
  }

  public readonly implementationId = RISEKeyringEntry.implementationId;
  public readonly id: KeyringEntryId;
  public readonly label: ValueAndUpdates<string | undefined>;
  public readonly canSign = new ValueAndUpdates(new DefaultValueProducer(true));

  private readonly labelProducer: DefaultValueProducer<string | undefined>;
  private readonly identities: LocalIdentity[];
  // "passphrase" is Lisk's word for an autogenerated 12 word english BIP39 mnemonic
  // encoded as a string. Since the BIP39 property is not used for anything but checksumming
  // we work with plain strings here.
  private readonly passphrases: Map<string, string>;

  constructor(data?: KeyringEntrySerializationString) {
    let id: KeyringEntryId;
    let label: string | undefined;
    const identities: LocalIdentity[] = [];
    const passphrases = new Map<string, string>();

    if (data) {
      const decodedData: LiskKeyringEntrySerialization = JSON.parse(data);

      // id
      id = decodedData.id as KeyringEntryId;

      // label
      label = decodedData.label;

      // identities
      for (const record of decodedData.identities) {
        const identity = RISEKeyringEntry.buildLocalIdentity(
          RISEKeyringEntry.algorithmFromString(record.localIdentity.pubkey.algo),
          Encoding.fromHex(record.localIdentity.pubkey.data) as PublicKeyBytes,
          record.localIdentity.label,
        );
        identities.push(identity);
        passphrases.set(identity.id, record.passphrase);
      }
    } else {
      id = RISEKeyringEntry.generateId();
    }

    this.id = id;
    this.labelProducer = new DefaultValueProducer<string | undefined>(label);
    this.label = new ValueAndUpdates(this.labelProducer);
    this.identities = identities;
    this.passphrases = passphrases;
  }

  public getIdentities(): ReadonlyArray<LocalIdentity> {
    return this.identities;
  }

  public setLabel(label: string | undefined): void {
    this.labelProducer.update(label);
  }

  public async createIdentity(passphrase?: string): Promise<LocalIdentity> {
    if (passphrase === undefined) {
      throw new Error("Passphrase must be set");
    }

    const keypair = await passphraseToKeypair(passphrase);

    const pubkey = {
      algo: Algorithm.ED25519,
      data: keypair.pubkey as PublicKeyBytes,
    };
    const identityId = RISEKeyringEntry.identityId({ pubkey });

    if (this.identities.find(i => i.id === identityId)) {
      throw new Error(
        "Identity ID collision: this happens when you try to create multiple identities with the same passphrase in the same entry.",
      );
    }

    const newIdentity: LocalIdentity = {
      pubkey: pubkey,
      label: undefined,
      id: identityId,
    };
    this.identities.push(newIdentity);
    this.passphrases.set(identityId, passphrase);

    return newIdentity;
  }

  public setIdentityLabel(identity: PublicIdentity, label: string | undefined): void {
    const identityId = RISEKeyringEntry.identityId(identity);
    const index = this.identities.findIndex(i => RISEKeyringEntry.identityId(i) === identityId);
    if (index === -1) {
      throw new Error("identity with id '" + identityId + "' not found");
    }

    // tslint:disable-next-line:no-object-mutation
    this.identities[index] = {
      ...this.identities[index],
      label: label,
    };
  }

  public serialize(): KeyringEntrySerializationString {
    const out: LiskKeyringEntrySerialization = {
      label: this.label.value,
      id: this.id,
      identities: this.identities.map(identity => {
        const passphrase = this.passphraseForIdentity(identity);
        return {
          localIdentity: {
            pubkey: {
              algo: identity.pubkey.algo,
              data: Encoding.toHex(identity.pubkey.data),
            },
            label: identity.label,
          },
          passphrase: passphrase,
        };
      }),
    };
    return JSON.stringify(out) as KeyringEntrySerializationString;
  }

  public clone(): KeyringEntry {
    return new RISEKeyringEntry(this.serialize());
  }

  public async createTransactionSignature(
    identity: PublicIdentity,
    transactionBytes: SignableBytes,
    prehashType: PrehashType,
    _: ChainId,
  ): Promise<SignatureBytes> {
    const passphrase = this.passphraseForIdentity(identity);
    const keypair = await passphraseToKeypair(passphrase);

    let hash: Uint8Array;
    switch (prehashType) {
      case PrehashType.Sha256:
        hash = new Sha256(transactionBytes).digest();
        break;
      default:
        throw new Error("Only prehash type sha256 is supported");
    }

    const signature = await Ed25519.createSignature(hash, keypair);
    return signature as SignatureBytes;
  }

  // This throws an exception when private key is missing
  private passphraseForIdentity(identity: PublicIdentity): string {
    const identityId = RISEKeyringEntry.identityId(identity);
    const passphrase = this.passphrases.get(identityId);
    if (!passphrase) {
      throw new Error("No passphrase found for identity '" + identityId + "'");
    }
    return passphrase;
  }
}
